/**
 * Generated by orval v8.4.1 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { apiFetch } from './mutator';
export interface PublisherRequest {
  /** @minLength 1 */
  name: string;
}

export interface Publisher {
  id?: string;
  name?: string;
  createdAt?: string;
  updatedAt?: string;
}

export interface DesignerRequest {
  /** @minLength 1 */
  name: string;
}

export interface Designer {
  id?: string;
  name?: string;
  createdAt?: string;
  updatedAt?: string;
}

export interface BoardGameRequest {
  /** @minLength 1 */
  title: string;
  yearPublished?: number;
  minPlayers?: number;
  maxPlayers?: number;
  minPlayTimeMinutes?: number;
  maxPlayTimeMinutes?: number;
  weight?: number;
  rating?: number;
  designerIds?: string[];
  publisherIds?: string[];
}

export interface BoardGameDesigner {
  designerId?: string;
}

export interface BoardGamePublisher {
  publisherId?: string;
}

export interface BoardGame {
  id?: string;
  title?: string;
  yearPublished?: number;
  minPlayers?: number;
  maxPlayers?: number;
  minPlayTimeMinutes?: number;
  maxPlayTimeMinutes?: number;
  weight?: number;
  rating?: number;
  hasImage?: boolean;
  designers?: BoardGameDesigner[];
  publishers?: BoardGamePublisher[];
  createdAt?: string;
  updatedAt?: string;
}

export interface CollectionEntryRequest {
  boardGameId?: string;
  condition?: string;
}

export interface UserBoardGame {
  id?: string;
  userId?: string;
  boardGameId?: string;
  condition?: string;
  createdAt?: string;
  updatedAt?: string;
}

export interface RegisterRequest {
  /** @minLength 1 */
  email: string;
  /**
   * @minLength 8
   * @maxLength 2147483647
   */
  password: string;
}

export interface AuthResponse {
  token?: string;
}

export interface LoginRequest {
  /** @minLength 1 */
  email: string;
  /** @minLength 1 */
  password: string;
}

export interface User {
  id?: string;
  email?: string;
  passwordHash?: string;
  role?: string;
  createdAt?: string;
  updatedAt?: string;
}

export interface UserCollectionResponse {
  user?: User;
  collection?: BoardGame[];
}

export type UploadBoardGameImageBody = {
  file: Blob;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export const getGetPublisherUrl = (id: string,) => {


  

  return `/api/publishers/${id}`
}

export const getPublisher = async (id: string, options?: RequestInit): Promise<Publisher> => {
  
  return apiFetch<Publisher>(getGetPublisherUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetPublisherQueryKey = (id: string,) => {
    return [
    `/api/publishers/${id}`
    ] as const;
    }

    
export const getGetPublisherQueryOptions = <TData = Awaited<ReturnType<typeof getPublisher>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublisherQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublisher>>> = ({ signal }) => getPublisher(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof getPublisher>>>
export type GetPublisherQueryError = unknown


export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublisher>>,
          TError,
          Awaited<ReturnType<typeof getPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublisher>>,
          TError,
          Awaited<ReturnType<typeof getPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPublisherQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export const getUpdatePublisherUrl = (id: string,) => {


  

  return `/api/publishers/${id}`
}

export const updatePublisher = async (id: string,
    publisherRequest: PublisherRequest, options?: RequestInit): Promise<Publisher> => {
  
  return apiFetch<Publisher>(getUpdatePublisherUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      publisherRequest,)
  }
);}
  



export const getUpdatePublisherMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{id: string;data: PublisherRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{id: string;data: PublisherRequest}, TContext> => {

const mutationKey = ['updatePublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePublisher>>, {id: string;data: PublisherRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updatePublisher(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof updatePublisher>>>
    export type UpdatePublisherMutationBody = PublisherRequest
    export type UpdatePublisherMutationError = unknown

    export const useUpdatePublisher = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{id: string;data: PublisherRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePublisher>>,
        TError,
        {id: string;data: PublisherRequest},
        TContext
      > => {
      return useMutation(getUpdatePublisherMutationOptions(options), queryClient);
    }
    
export const getDeletePublisherUrl = (id: string,) => {


  

  return `/api/publishers/${id}`
}

export const deletePublisher = async (id: string, options?: RequestInit): Promise<void> => {
  
  return apiFetch<void>(getDeletePublisherUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getDeletePublisherMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{id: string}, TContext> => {

const mutationKey = ['deletePublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePublisher>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deletePublisher(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof deletePublisher>>>
    
    export type DeletePublisherMutationError = unknown

    export const useDeletePublisher = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePublisher>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getDeletePublisherMutationOptions(options), queryClient);
    }
    
export const getGetDesignerUrl = (id: string,) => {


  

  return `/api/designers/${id}`
}

export const getDesigner = async (id: string, options?: RequestInit): Promise<Designer> => {
  
  return apiFetch<Designer>(getGetDesignerUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetDesignerQueryKey = (id: string,) => {
    return [
    `/api/designers/${id}`
    ] as const;
    }

    
export const getGetDesignerQueryOptions = <TData = Awaited<ReturnType<typeof getDesigner>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesigner>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDesignerQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDesigner>>> = ({ signal }) => getDesigner(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDesigner>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDesignerQueryResult = NonNullable<Awaited<ReturnType<typeof getDesigner>>>
export type GetDesignerQueryError = unknown


export function useGetDesigner<TData = Awaited<ReturnType<typeof getDesigner>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesigner>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDesigner>>,
          TError,
          Awaited<ReturnType<typeof getDesigner>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDesigner<TData = Awaited<ReturnType<typeof getDesigner>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesigner>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDesigner>>,
          TError,
          Awaited<ReturnType<typeof getDesigner>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDesigner<TData = Awaited<ReturnType<typeof getDesigner>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesigner>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetDesigner<TData = Awaited<ReturnType<typeof getDesigner>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesigner>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDesignerQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export const getUpdateDesignerUrl = (id: string,) => {


  

  return `/api/designers/${id}`
}

export const updateDesigner = async (id: string,
    designerRequest: DesignerRequest, options?: RequestInit): Promise<Designer> => {
  
  return apiFetch<Designer>(getUpdateDesignerUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      designerRequest,)
  }
);}
  



export const getUpdateDesignerMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDesigner>>, TError,{id: string;data: DesignerRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDesigner>>, TError,{id: string;data: DesignerRequest}, TContext> => {

const mutationKey = ['updateDesigner'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDesigner>>, {id: string;data: DesignerRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDesigner(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDesignerMutationResult = NonNullable<Awaited<ReturnType<typeof updateDesigner>>>
    export type UpdateDesignerMutationBody = DesignerRequest
    export type UpdateDesignerMutationError = unknown

    export const useUpdateDesigner = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDesigner>>, TError,{id: string;data: DesignerRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDesigner>>,
        TError,
        {id: string;data: DesignerRequest},
        TContext
      > => {
      return useMutation(getUpdateDesignerMutationOptions(options), queryClient);
    }
    
export const getDeleteDesignerUrl = (id: string,) => {


  

  return `/api/designers/${id}`
}

export const deleteDesigner = async (id: string, options?: RequestInit): Promise<void> => {
  
  return apiFetch<void>(getDeleteDesignerUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getDeleteDesignerMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDesigner>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDesigner>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteDesigner'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDesigner>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteDesigner(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDesignerMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDesigner>>>
    
    export type DeleteDesignerMutationError = unknown

    export const useDeleteDesigner = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDesigner>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDesigner>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getDeleteDesignerMutationOptions(options), queryClient);
    }
    
export const getGetBoardGameUrl = (id: string,) => {


  

  return `/api/board-games/${id}`
}

export const getBoardGame = async (id: string, options?: RequestInit): Promise<BoardGame> => {
  
  return apiFetch<BoardGame>(getGetBoardGameUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetBoardGameQueryKey = (id: string,) => {
    return [
    `/api/board-games/${id}`
    ] as const;
    }

    
export const getGetBoardGameQueryOptions = <TData = Awaited<ReturnType<typeof getBoardGame>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBoardGame>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBoardGameQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBoardGame>>> = ({ signal }) => getBoardGame(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBoardGame>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBoardGameQueryResult = NonNullable<Awaited<ReturnType<typeof getBoardGame>>>
export type GetBoardGameQueryError = unknown


export function useGetBoardGame<TData = Awaited<ReturnType<typeof getBoardGame>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBoardGame>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBoardGame>>,
          TError,
          Awaited<ReturnType<typeof getBoardGame>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBoardGame<TData = Awaited<ReturnType<typeof getBoardGame>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBoardGame>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBoardGame>>,
          TError,
          Awaited<ReturnType<typeof getBoardGame>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBoardGame<TData = Awaited<ReturnType<typeof getBoardGame>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBoardGame>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetBoardGame<TData = Awaited<ReturnType<typeof getBoardGame>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBoardGame>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBoardGameQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export const getUpdateBoardGameUrl = (id: string,) => {


  

  return `/api/board-games/${id}`
}

export const updateBoardGame = async (id: string,
    boardGameRequest: BoardGameRequest, options?: RequestInit): Promise<BoardGame> => {
  
  return apiFetch<BoardGame>(getUpdateBoardGameUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      boardGameRequest,)
  }
);}
  



export const getUpdateBoardGameMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBoardGame>>, TError,{id: string;data: BoardGameRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateBoardGame>>, TError,{id: string;data: BoardGameRequest}, TContext> => {

const mutationKey = ['updateBoardGame'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBoardGame>>, {id: string;data: BoardGameRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBoardGame(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBoardGameMutationResult = NonNullable<Awaited<ReturnType<typeof updateBoardGame>>>
    export type UpdateBoardGameMutationBody = BoardGameRequest
    export type UpdateBoardGameMutationError = unknown

    export const useUpdateBoardGame = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBoardGame>>, TError,{id: string;data: BoardGameRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBoardGame>>,
        TError,
        {id: string;data: BoardGameRequest},
        TContext
      > => {
      return useMutation(getUpdateBoardGameMutationOptions(options), queryClient);
    }
    
export const getDeleteBoardGameUrl = (id: string,) => {


  

  return `/api/board-games/${id}`
}

export const deleteBoardGame = async (id: string, options?: RequestInit): Promise<void> => {
  
  return apiFetch<void>(getDeleteBoardGameUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getDeleteBoardGameMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBoardGame>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBoardGame>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteBoardGame'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBoardGame>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteBoardGame(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBoardGameMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBoardGame>>>
    
    export type DeleteBoardGameMutationError = unknown

    export const useDeleteBoardGame = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBoardGame>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBoardGame>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getDeleteBoardGameMutationOptions(options), queryClient);
    }
    
export const getAddToCollectionUrl = (id: string,) => {


  

  return `/api/users/${id}/board-games`
}

export const addToCollection = async (id: string,
    collectionEntryRequest: CollectionEntryRequest, options?: RequestInit): Promise<UserBoardGame> => {
  
  return apiFetch<UserBoardGame>(getAddToCollectionUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      collectionEntryRequest,)
  }
);}
  



export const getAddToCollectionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToCollection>>, TError,{id: string;data: CollectionEntryRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof addToCollection>>, TError,{id: string;data: CollectionEntryRequest}, TContext> => {

const mutationKey = ['addToCollection'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToCollection>>, {id: string;data: CollectionEntryRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  addToCollection(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddToCollectionMutationResult = NonNullable<Awaited<ReturnType<typeof addToCollection>>>
    export type AddToCollectionMutationBody = CollectionEntryRequest
    export type AddToCollectionMutationError = unknown

    export const useAddToCollection = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToCollection>>, TError,{id: string;data: CollectionEntryRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addToCollection>>,
        TError,
        {id: string;data: CollectionEntryRequest},
        TContext
      > => {
      return useMutation(getAddToCollectionMutationOptions(options), queryClient);
    }
    
export const getListPublishersUrl = () => {


  

  return `/api/publishers`
}

export const listPublishers = async ( options?: RequestInit): Promise<Publisher[]> => {
  
  return apiFetch<Publisher[]>(getListPublishersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListPublishersQueryKey = () => {
    return [
    `/api/publishers`
    ] as const;
    }

    
export const getListPublishersQueryOptions = <TData = Awaited<ReturnType<typeof listPublishers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublishersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublishers>>> = ({ signal }) => listPublishers({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPublishersQueryResult = NonNullable<Awaited<ReturnType<typeof listPublishers>>>
export type ListPublishersQueryError = unknown


export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPublishers>>,
          TError,
          Awaited<ReturnType<typeof listPublishers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPublishers>>,
          TError,
          Awaited<ReturnType<typeof listPublishers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPublishersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export const getCreatePublisherUrl = () => {


  

  return `/api/publishers`
}

export const createPublisher = async (publisherRequest: PublisherRequest, options?: RequestInit): Promise<Publisher> => {
  
  return apiFetch<Publisher>(getCreatePublisherUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      publisherRequest,)
  }
);}
  



export const getCreatePublisherMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: PublisherRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: PublisherRequest}, TContext> => {

const mutationKey = ['createPublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPublisher>>, {data: PublisherRequest}> = (props) => {
          const {data} = props ?? {};

          return  createPublisher(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof createPublisher>>>
    export type CreatePublisherMutationBody = PublisherRequest
    export type CreatePublisherMutationError = unknown

    export const useCreatePublisher = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: PublisherRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPublisher>>,
        TError,
        {data: PublisherRequest},
        TContext
      > => {
      return useMutation(getCreatePublisherMutationOptions(options), queryClient);
    }
    
export const getListDesignersUrl = () => {


  

  return `/api/designers`
}

export const listDesigners = async ( options?: RequestInit): Promise<Designer[]> => {
  
  return apiFetch<Designer[]>(getListDesignersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListDesignersQueryKey = () => {
    return [
    `/api/designers`
    ] as const;
    }

    
export const getListDesignersQueryOptions = <TData = Awaited<ReturnType<typeof listDesigners>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDesigners>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListDesignersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listDesigners>>> = ({ signal }) => listDesigners({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listDesigners>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListDesignersQueryResult = NonNullable<Awaited<ReturnType<typeof listDesigners>>>
export type ListDesignersQueryError = unknown


export function useListDesigners<TData = Awaited<ReturnType<typeof listDesigners>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDesigners>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDesigners>>,
          TError,
          Awaited<ReturnType<typeof listDesigners>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDesigners<TData = Awaited<ReturnType<typeof listDesigners>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDesigners>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDesigners>>,
          TError,
          Awaited<ReturnType<typeof listDesigners>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDesigners<TData = Awaited<ReturnType<typeof listDesigners>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDesigners>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListDesigners<TData = Awaited<ReturnType<typeof listDesigners>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDesigners>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListDesignersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export const getCreateDesignerUrl = () => {


  

  return `/api/designers`
}

export const createDesigner = async (designerRequest: DesignerRequest, options?: RequestInit): Promise<Designer> => {
  
  return apiFetch<Designer>(getCreateDesignerUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      designerRequest,)
  }
);}
  



export const getCreateDesignerMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDesigner>>, TError,{data: DesignerRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createDesigner>>, TError,{data: DesignerRequest}, TContext> => {

const mutationKey = ['createDesigner'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDesigner>>, {data: DesignerRequest}> = (props) => {
          const {data} = props ?? {};

          return  createDesigner(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDesignerMutationResult = NonNullable<Awaited<ReturnType<typeof createDesigner>>>
    export type CreateDesignerMutationBody = DesignerRequest
    export type CreateDesignerMutationError = unknown

    export const useCreateDesigner = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDesigner>>, TError,{data: DesignerRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDesigner>>,
        TError,
        {data: DesignerRequest},
        TContext
      > => {
      return useMutation(getCreateDesignerMutationOptions(options), queryClient);
    }
    
export const getListBoardGamesUrl = () => {


  

  return `/api/board-games`
}

export const listBoardGames = async ( options?: RequestInit): Promise<BoardGame[]> => {
  
  return apiFetch<BoardGame[]>(getListBoardGamesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListBoardGamesQueryKey = () => {
    return [
    `/api/board-games`
    ] as const;
    }

    
export const getListBoardGamesQueryOptions = <TData = Awaited<ReturnType<typeof listBoardGames>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBoardGames>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListBoardGamesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listBoardGames>>> = ({ signal }) => listBoardGames({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listBoardGames>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBoardGamesQueryResult = NonNullable<Awaited<ReturnType<typeof listBoardGames>>>
export type ListBoardGamesQueryError = unknown


export function useListBoardGames<TData = Awaited<ReturnType<typeof listBoardGames>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBoardGames>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBoardGames>>,
          TError,
          Awaited<ReturnType<typeof listBoardGames>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBoardGames<TData = Awaited<ReturnType<typeof listBoardGames>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBoardGames>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBoardGames>>,
          TError,
          Awaited<ReturnType<typeof listBoardGames>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBoardGames<TData = Awaited<ReturnType<typeof listBoardGames>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBoardGames>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListBoardGames<TData = Awaited<ReturnType<typeof listBoardGames>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBoardGames>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListBoardGamesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export const getCreateBoardGameUrl = () => {


  

  return `/api/board-games`
}

export const createBoardGame = async (boardGameRequest: BoardGameRequest, options?: RequestInit): Promise<BoardGame> => {
  
  return apiFetch<BoardGame>(getCreateBoardGameUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      boardGameRequest,)
  }
);}
  



export const getCreateBoardGameMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBoardGame>>, TError,{data: BoardGameRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createBoardGame>>, TError,{data: BoardGameRequest}, TContext> => {

const mutationKey = ['createBoardGame'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBoardGame>>, {data: BoardGameRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBoardGame(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBoardGameMutationResult = NonNullable<Awaited<ReturnType<typeof createBoardGame>>>
    export type CreateBoardGameMutationBody = BoardGameRequest
    export type CreateBoardGameMutationError = unknown

    export const useCreateBoardGame = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBoardGame>>, TError,{data: BoardGameRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBoardGame>>,
        TError,
        {data: BoardGameRequest},
        TContext
      > => {
      return useMutation(getCreateBoardGameMutationOptions(options), queryClient);
    }
    
export const getUploadBoardGameImageUrl = (id: string,) => {


  

  return `/api/board-games/${id}/image`
}

export const uploadBoardGameImage = async (id: string,
    uploadBoardGameImageBody: UploadBoardGameImageBody, options?: RequestInit): Promise<void> => {
    const formData = new FormData();
formData.append(`file`, uploadBoardGameImageBody.file);

  return apiFetch<void>(getUploadBoardGameImageUrl(id),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}
  



export const getUploadBoardGameImageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadBoardGameImage>>, TError,{id: string;data: UploadBoardGameImageBody}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof uploadBoardGameImage>>, TError,{id: string;data: UploadBoardGameImageBody}, TContext> => {

const mutationKey = ['uploadBoardGameImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadBoardGameImage>>, {id: string;data: UploadBoardGameImageBody}> = (props) => {
          const {id,data} = props ?? {};

          return  uploadBoardGameImage(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UploadBoardGameImageMutationResult = NonNullable<Awaited<ReturnType<typeof uploadBoardGameImage>>>
    export type UploadBoardGameImageMutationBody = UploadBoardGameImageBody
    export type UploadBoardGameImageMutationError = unknown

    export const useUploadBoardGameImage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadBoardGameImage>>, TError,{id: string;data: UploadBoardGameImageBody}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadBoardGameImage>>,
        TError,
        {id: string;data: UploadBoardGameImageBody},
        TContext
      > => {
      return useMutation(getUploadBoardGameImageMutationOptions(options), queryClient);
    }
    
export const getRegisterUrl = () => {


  

  return `/api/auth/register`
}

export const register = async (registerRequest: RegisterRequest, options?: RequestInit): Promise<AuthResponse> => {
  
  return apiFetch<AuthResponse>(getRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registerRequest,)
  }
);}
  



export const getRegisterMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext> => {

const mutationKey = ['register'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  register(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
    export type RegisterMutationBody = RegisterRequest
    export type RegisterMutationError = unknown

    export const useRegister = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof register>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {
      return useMutation(getRegisterMutationOptions(options), queryClient);
    }
    
export const getLoginUrl = () => {


  

  return `/api/auth/login`
}

export const login = async (loginRequest: LoginRequest, options?: RequestInit): Promise<AuthResponse> => {
  
  return apiFetch<AuthResponse>(getLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginRequest,)
  }
);}
  



export const getLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = unknown

    export const useLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {
      return useMutation(getLoginMutationOptions(options), queryClient);
    }
    
export const getListUsersUrl = () => {


  

  return `/api/users`
}

export const listUsers = async ( options?: RequestInit): Promise<User[]> => {
  
  return apiFetch<User[]>(getListUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListUsersQueryKey = () => {
    return [
    `/api/users`
    ] as const;
    }

    
export const getListUsersQueryOptions = <TData = Awaited<ReturnType<typeof listUsers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = ({ signal }) => listUsers({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof listUsers>>>
export type ListUsersQueryError = unknown


export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export const getGetUserUrl = (id: string,) => {


  

  return `/api/users/${id}`
}

export const getUser = async (id: string, options?: RequestInit): Promise<UserCollectionResponse> => {
  
  return apiFetch<UserCollectionResponse>(getGetUserUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetUserQueryKey = (id: string,) => {
    return [
    `/api/users/${id}`
    ] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = unknown


export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export const getDeleteUserUrl = (id: string,) => {


  

  return `/api/users/${id}`
}

export const deleteUser = async (id: string, options?: RequestInit): Promise<void> => {
  
  return apiFetch<void>(getDeleteUserUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getDeleteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteUser(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = unknown

    export const useDeleteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getDeleteUserMutationOptions(options), queryClient);
    }
    
export const getRemoveFromCollectionUrl = (id: string,
    gameId: string,) => {


  

  return `/api/users/${id}/board-games/${gameId}`
}

export const removeFromCollection = async (id: string,
    gameId: string, options?: RequestInit): Promise<void> => {
  
  return apiFetch<void>(getRemoveFromCollectionUrl(id,gameId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getRemoveFromCollectionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromCollection>>, TError,{id: string;gameId: string}, TContext>, request?: SecondParameter<typeof apiFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromCollection>>, TError,{id: string;gameId: string}, TContext> => {

const mutationKey = ['removeFromCollection'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromCollection>>, {id: string;gameId: string}> = (props) => {
          const {id,gameId} = props ?? {};

          return  removeFromCollection(id,gameId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromCollectionMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromCollection>>>
    
    export type RemoveFromCollectionMutationError = unknown

    export const useRemoveFromCollection = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromCollection>>, TError,{id: string;gameId: string}, TContext>, request?: SecondParameter<typeof apiFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeFromCollection>>,
        TError,
        {id: string;gameId: string},
        TContext
      > => {
      return useMutation(getRemoveFromCollectionMutationOptions(options), queryClient);
    }
